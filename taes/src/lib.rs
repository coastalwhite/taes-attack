#![cfg_attr(not(test), no_std)]

macro_rules! cc_bs {
    ($b0:expr , $b1:expr, $b2:expr, $b3:expr $(,)?) => {{
        let b0 = u32::from($b0);
        let b1 = u32::from($b1);
        let b2 = u32::from($b2);
        let b3 = u32::from($b3);

        (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
    }};
}

macro_rules! idx {
    ($bs:expr , $r:expr, $c:expr $(,)?) => {
        (($bs[$c] >> ((3 - $r) * 8)) & 0xFF) as usize
    };
}

#[cfg(test)]
mod reference;

static SBOX: [u8; 256] = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
];

pub type TTable = [[u32; 256]; 4];

fn xtime(b: u8) -> u8 {
    if b & 0x80 == 0 {
        b << 1
    } else {
        (b << 1) ^ 0x1B
    }
}

fn mul(mut b: u8, mut x: u8) -> u8 {
    let mut s = 0u8;

    while x != 0 {
        if x & 1 == 1 {
            s ^= b;
        }

        b = xtime(b);
        x >>= 1;
    }

    s
}

pub fn fill_ttable(ttable: &mut TTable) {
    for b in 0..=u8::MAX {
        let sb = SBOX[b as usize];
        let sb_2 = mul(sb, 2);
        let sb_3 = mul(sb, 3);

        let sb = sb as u32;
        let sb_2 = sb_2 as u32;
        let sb_3 = sb_3 as u32;

        ttable[0][b as usize] = cc_bs!(sb_2, sb, sb, sb_3);
        ttable[1][b as usize] = cc_bs!(sb_3, sb_2, sb, sb);
        ttable[2][b as usize] = cc_bs!(sb, sb_3, sb_2, sb);
        ttable[3][b as usize] = cc_bs!(sb, sb, sb_3, sb_2);
    }
}

pub fn tt_forward(cols: &mut [u32; 4], te: &TTable) {
    // 0 1 2 3          0 4 8 c
    // 4 5 6 7          1 5 9 d
    // 8 9 a b          2 6 a e
    // c d e f          3 7 b f

    // r0 = T0[a0,0] ^ T1[a1,3] ^ T2[a2,2] ^ T3[a3,1]
    // r1 = T0[a0,1] ^ T1[a1,0] ^ T2[a2,3] ^ T3[a3,2]
    // r2 = T0[a0,2] ^ T1[a1,1] ^ T2[a2,0] ^ T3[a3,3]
    // r3 = T0[a0,3] ^ T1[a1,2] ^ T2[a2,1] ^ T3[a3,0]
    
    let r0 = te[0][idx!(cols, 0, 0)]
        ^ te[1][idx!(cols, 1, 1)]
        ^ te[2][idx!(cols, 2, 2)]
        ^ te[3][idx!(cols, 3, 3)];
    let r1 = te[0][idx!(cols, 0, 1)]
        ^ te[1][idx!(cols, 1, 2)]
        ^ te[2][idx!(cols, 2, 3)]
        ^ te[3][idx!(cols, 3, 0)];
    let r2 = te[0][idx!(cols, 0, 2)]
        ^ te[1][idx!(cols, 1, 3)]
        ^ te[2][idx!(cols, 2, 0)]
        ^ te[3][idx!(cols, 3, 1)];
    let r3 = te[0][idx!(cols, 0, 3)]
        ^ te[1][idx!(cols, 1, 0)]
        ^ te[2][idx!(cols, 2, 1)]
        ^ te[3][idx!(cols, 3, 2)];

    cols[0] = r0;
    cols[1] = r1;
    cols[2] = r2;
    cols[3] = r3;
}

pub fn tt_round(cols: &mut [u32; 4], k: [u32; 4], te: &TTable) {
    tt_forward(cols, te);

    cols[0] ^= k[0];
    cols[1] ^= k[1];
    cols[2] ^= k[2];
    cols[3] ^= k[3];
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! tv_test {
        ($input:expr) => {
            let bs = $input.to_be_bytes();

            let mut ttable = [[0; 256]; 4];

            fill_ttable(&mut ttable);

            let bs = [
                cc_bs!(bs[0], bs[1], bs[2], bs[3]),
                cc_bs!(bs[4], bs[5], bs[6], bs[7]),
                cc_bs!(bs[8], bs[9], bs[10], bs[11]),
                cc_bs!(bs[12], bs[13], bs[14], bs[15]),
            ];

            let mut tt_bs = bs.clone();
            let mut ref_bs = bs.clone();

            tt_forward(&mut tt_bs, &ttable);

            reference::sub_bytes(&mut ref_bs);
            reference::shift_rows(&mut ref_bs);
            reference::mix_columns(&mut ref_bs);

            assert_eq!(tt_bs, ref_bs);
        };
    }

    #[test]
    fn equiv() {
        let input = 0x00112233445566778899aabbccddeeffu128;

        tv_test!(input);
    }

    #[test]
    fn poly_mul() {
        assert_eq!(mul(0x57, 0x13), 0xFE);
        assert_eq!(mul(0x63, 3), 0xA5);
    }
}
